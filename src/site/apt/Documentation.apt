                                    ------
                                    Documentation to Ejb3Unit
                                    ------
				    Fabian Bauschulte, Daniel Wiese
                                    ------
                                    2007
					


Documentation

* Preface

  The Ejb3Unit project will automate Entity and Session bean testing outside the container for the EJB 3.0 specification. Ejb3Unit can execute automated standalone JUnit test for all EJB 3.0 standard conform J2EE projects. 

*  Approach

  EJb3Unit can be configured for an in memory database (default setting) or for a user defined target database (never use production databases). Ejb3Unit provides three different test categories:

  [[1]]	<<Entity bean test:>> Fully automated test. Entity bens are randomly generated and written / read against the database (or in memory db). Equals and HashCode methods are checked automatically. Nullable fields are tested.

  [[2]]	<<Mocked session bean test:>> A session bean class is created and for all Ejb3 dependency injection field’s mock objects are injected. This test allows testing of an Session bean in isolation.

  [[3]]	<<Session bean test:>> The tested session bean and all referenced session beans are created (annotated with @EJB for dependency injection). Also DataSource and SessionContext are injected. The in memory database is initialized with predefined data using comma separated value files. Each .csv file represents data for one table (using the mapping definitions form the corresponding entity bean). This test is an integration test.

* Configuration

  Ejb3Unit use a single configuration file named ejb3unit.properties. This file has to be present in your class path. All necessary configuration is done here (like the database driver, connection, etc.) . This is an example for the in memory database:

----
### The ejb3unit configuration file ###
ejb3unit.inMemoryTest=true
ejb3unit.show_sql=false

----

  This is an example of a user defined database:

----
### The ejb3unit configuration file ###
ejb3unit.connection.url=jdbc:protokoll:db://host:port/shema
ejb3unit.connection.driver_class=my.jdbc.Driver
ejb3unit.connection.username=ejb3unit
ejb3unit.connection.password=ejb3unit
ejb3unit.dialect=org.hibernate.dialect.SQLServerDialect
ejb3unit.show_sql=true

## values are create-drop, create, update ##
ejb3unit.shema.update=create
----

* Entity-Bean test 

  With EJB3Unit you can create and test entity beans outside the container. 
EJB3Unit will automate your entity bean testing. Ejb3Unit will generate random (or customized) entity beans for you and test the read write access against your database. During this test possible data truncations, wrong declared nullable fields or other possible schema errors will be checked. Furthermore EJB3Unit will check your equals and hashCode implementations for your Entity beans. 

** First simple example

  How to write a simple Entity bean test?

  We assume that a Book bean is an entity bean

----
@Entity
@Table(name = "AUTOR")
public class Author implements Serializable{
    
    @Id(generate = GeneratorType.NONE)
    private int id;
    
    private String name;
    
    @Column(name="creation_timestamp", nullable=false)
    private Date created;
}
----
  
  If we want to write a JUnit test for this entity bean we write the following piece of code:

----
public class Author Test 
extends BaseEntityTest<Author> {

	/**
	 * Constructor.
	 */
	public StockWKNBoTest() {
		super(Author.class);
	}
}
----

* Mocked session bean test

  EJB3Unit is able to inject to annotated fields (using EJB 3 (JSR 220) annotations), mock objects. The MockedSessionBeanTest can be used to automate the dependency injection and execute easily test with mocked dependencies. The basic test can be configured by extending the MockedSessionBeanTest class. The next example shows ho to test a session bean class called MyOtherSessionBean:

----
public class MyOtherSessionBeanTest extends
		MockedSessionBeanTest<MyOtherSessionBean> {

	/**
	 * Constructor.
	 */
	public MyOtherSessionBeanTest() {
		super(MyOtherSessionBean.class);
	}

	public void test_executeOperation() {
	…
	}
}
----

  In the test method test_executeOperation() we can specify which operation on which JMock objects will be executed. We can specify this e.g.:

----
public void test_executeOperation() {
	MyOtherSessionBean toTest = this.getBeanToTest();
	final Mock mySessionBean = 
       this.getMockControl("mySessionBean");

	mySessionBean.expects(once()).method("getDs").
        will(returnValue(ds));
		
	//call the expected operation
	toTest.executeOperation();
}
----
  
  With the method getMockControl("propertyName") we can retrieve the Mock control object for every property in the session bean.

*  Session bean test:

  With EJB3Unit you can create and test session beans outside the container. Every will may be
  setup with a predefined set of data. This data is loaded using predefined data sets (CSV files).
  <<This means every test can rely on a well defined set of data loaded into the database.>> 
  EJB3Unit will support EJB 3 dependency injection, life cycle methods and 
  other EJB 3 features for statefull and stateless session beans.

  Currently following dependeny injection attributes are supported:
  
 [[1]]	@EJB dependency injection of other Stateless/Statefull session beans. The Session bean implementation is discovered automatically at runtime

 [[2]]  @Resource dependency injection is supported for following resources:
 
 [[3]]	@DataSource : A data source implementation is Injected (conform to the Ejb3Unit) settings

 [[4]]	@PersistenceContext EntityManager: A full function implementation of the EJB 3.0 EntityManager is injected automatically

----
public class MySessionBeanTest extends
		BaseSessionBeanTest<SaleAccessService> {


	private static final Class[] usedBeans = { StockWKNBo.class };

	private static final CSVInitialDataSet CSV_SET = 
		new CSVInitialDataSet<StockWKNBo>(
			StockWKNBo.class, "germanStocks.csv", 
			"wkn", "stockName", "isin");

	/**
	 * Constructor.
	 */
	public MySessionBeanTest() {
		super(MySessionBean.class, usedBeans,
				new StockWKNEntityInitialDataSet(), CSV_SET);
	}

	/**
	 * Testmethod.
	 */
	public void testBaunWithPreloadedData() {
		SaleAccessService toTest = this.getBeanToTest();
	}
}
----

   This test will load the in memory database, or a user defined database, with a data defined in the "germanStocks.csv".
   This unit test tests the session bean against the configured database (default is the in memory database). In this example the test 
   is using only a single entity bean named "StockWKNBo.class" and only one CSV data set. If a session bean is interacting
   with multiple entity beans and multiple db tables, the test has to be adapted, by adding these entity beans und unsing multiple
   CSV data loaders.

  <<That’s it!>>  It’s not that much code for y complete entity bean JUnit test!

  But what will happen behind the facade? To read an answer to that question please download refer to {{{http://ejb3unit.sourceforge.net/doc/Ejb3Unit.doc}detailed ejb3unit documenation}}
