package com.bm.introspectors;

import java.beans.PropertyDescriptor;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ManyToOne;
import javax.persistence.MappedSuperclass;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.Transient;

import org.apache.commons.beanutils.PropertyUtilsBean;
import org.slf4j.Logger;

import com.bm.introspectors.relations.GlobalPrimaryKeyStore;
import com.bm.introspectors.relations.GlobalRelationStore;
import com.bm.introspectors.relations.ManyToOneRelation;
import com.bm.introspectors.relations.OneToManyRelation;
import com.bm.introspectors.relations.OneToOneRelation;
import com.bm.introspectors.relations.RelationPropertyResolver;

/**
 * This class implements the common methods for all concrete inspectors.
 * 
 * @author Daniel Wiese
 * @param <T> -
 *            the type of the class to inspect
 * @since 07.10.2005
 */
public abstract class AbstractPersistentClassIntrospector<T> implements Introspector<T> {

    /** if no lengths are defined, use a large number as default length. * */
    private static final int DEFAULTLENGTH = 652345;

    /** holds the persistent fields of the class * */
    private final List<Property> persitentProperties = new ArrayList<Property>();

    /** holds the transient fields of the class * */
    private final List<Property> transientFields = new ArrayList<Property>();

    /** holds the meta information for persistent fields * */
    protected final Map<Property, PersistentPropertyInfo> fieldInfo = new HashMap<Property, PersistentPropertyInfo>();

    /** holds the pk fields of the class * */
    private final Set<Property> pkFields = new HashSet<Property>();

    /** holds the meta information for primary key fields * */
    protected final Map<Property, PrimaryKeyInfo> pkFieldInfo = new HashMap<Property, PrimaryKeyInfo>();

    private final PropertyUtilsBean propUtils = new PropertyUtilsBean();

    /** the class represented by this introspector (e.g. the entity bean)* */
    private Class<T> representingClass;

    /**
     * If the access type is field, we will extract all the necessary meta informations form the fields
     * 
     * @param toInspect -
     *            the class to inspect
     */
    protected void processAccessTypeField(Class<T> toInspect) {
        this.representingClass = toInspect;
        // extract meta information
        Class<? super T> clazz = toInspect;
        do {
        	Field[] fields = clazz.getDeclaredFields();
        	for (Field aktField : fields) {
        		// dont's introspect fields generated by hibernate
        		if (!this.isStatic(aktField) && !aktField.getName().startsWith("$")) {
        			Annotation[] fieldAnnotations = aktField.getAnnotations();
        			this.processAnnotations(toInspect, new Property(aktField), fieldAnnotations);
        		}
        	}
        	clazz = clazz.getSuperclass();
        }
        while (clazz != null && (clazz.getAnnotation(Entity.class) != null 
        		                 || clazz.getAnnotation(MappedSuperclass.class) != null));
    }

    /**
     * If the access type is property, we will extract all the necessary meta informations form the getter
     * methods
     * 
     * @param toInspect -
     *            the class to inspect
     */
    protected void processAccessTypeProperty(Class<T> toInspect) {
        this.representingClass = toInspect;
        // extract meta information
        PropertyDescriptor[] properties = this.propUtils.getPropertyDescriptors(toInspect);

        for (PropertyDescriptor aktProperty : properties) {
            // dont's introspect fields generated by hibernate
            if (!aktProperty.getReadMethod().getName().equals("getClass")) {
                Annotation[] methodAnnotations = aktProperty.getReadMethod().getAnnotations();
                this.processAnnotations(toInspect, new Property(aktProperty.getReadMethod().getDeclaringClass(), aktProperty), methodAnnotations);

            }
        }
    }

    /**
     * This method returns informations about a persistent field.
     * 
     * @param toCheck
     *            the property for persistent db field
     * @see com.bm.introspectors.Introspector#getPresistentFieldInfo(Property)
     * @return persistent property info
     */
    public PersistentPropertyInfo getPresistentFieldInfo(Property toCheck) {
        if (this.fieldInfo.containsKey(toCheck)) {
            return fieldInfo.get(toCheck);
        }
        throw new RuntimeException("The field " + toCheck.getName() + " is not a persitent field");

    }

    /**
     * This method returns informations about a persistent field.
     * 
     * @param toCheck
     *            the property for primary key
     * @see com.bm.introspectors.Introspector#getPrimaryKeyInfo(Property)
     * @return pk info
     */
    public PrimaryKeyInfo getPrimaryKeyInfo(Property toCheck) {
        if (this.pkFieldInfo.containsKey(toCheck)) {
            return pkFieldInfo.get(toCheck);
        }
        throw new RuntimeException("The field " + toCheck.getName() + " is not a primary key field");
    }

    /**
     * Returns the persistent fields.
     * 
     * @see com.bm.introspectors.Introspector#getPersitentProperties()
     * @return the list of persistent fields
     */
    public List<Property> getPersitentProperties() {
        return persitentProperties;
    }

    /**
     * Return the primary key fields.
     * 
     * @see com.bm.introspectors.Introspector#getPkFields()
     * @return the list of primary key fields
     */
    public Set<Property> getPkFields() {
        return pkFields;
    }

    /**
     * Returns the transientFields.
     * 
     * @return Returns the transientFields.
     */
    public List<Property> getTransientFields() {
        return transientFields;
    }

    /**
     * Returns a value of an field.
     * 
     * @author Daniel Wiese
     * @param instance -
     *            the instance (Typed)
     * @param toGet -
     *            the parameter to get
     * @return - the value of the parameter of the instance
     * @throws IllegalAccessException -
     *             in error case
     * @since 15.10.2005
     */
    public Object getField(T instance, Property toGet) throws IllegalAccessException {

        return toGet.getField(instance);
    }

    /**
     * Sets a value of the field.
     * 
     * @author Daniel Wiese
     * @param instance -
     *            the instance (Typed)
     * @param toSet -
     *            the parameter to set
     * @param value -
     *            the new value
     * @throws IllegalAccessException -
     *             in error case
     * @since 15.10.2005
     */
    public void setField(T instance, Property toSet, Object value) throws IllegalAccessException {
        toSet.setField(instance, value);
    }

    /**
     * Check if the field is static
     * 
     * @param toCheck
     *            -the field to check
     * @return - true if static
     */
    private boolean isStatic(Field toCheck) {
        return Modifier.isStatic(toCheck.getModifiers());

    }

    /**
     * Analyse the annotation of a (field or getterMethod)
     * 
     * @param aktProperty -
     *            the property
     * @param propertyAnnotations -
     *            the corresponding annotations
     * @param classToInspect -
     *            the class to inspect
     */
    private void processAnnotations(Class<T> classToInspect, Property aktProperty,
            Annotation[] propertyAnnotations) {
        boolean isTransient = false;
        List<DbMappingInfo> mappingInfoList = new ArrayList<DbMappingInfo>();
        String joinColumnName = null;
        
            if (GlobalRelationStore.getStore().getProperty(classToInspect, aktProperty.getName()) != null) {
                    getLogger().debug("Attribute " + aktProperty.getName() + " already processed. Skipping.");
                    return;
            }  else {
                    getLogger().debug("Processing attribute " + aktProperty.getName());
                    GlobalRelationStore.getStore().put(classToInspect, aktProperty);
            }
        
        
        // create a instance if the file is a persistent field
        final PersistentPropertyInfo aktFieldInfo = new PersistentPropertyInfo();
        // initial name
        aktFieldInfo.setDbName(aktProperty.getName());
        aktFieldInfo.setLength(DEFAULTLENGTH);

        // look into the annotations
        for (Annotation a : propertyAnnotations) {
            
            // skip transient fields
            if (a instanceof Transient) {
                isTransient = true;
            }

            // extract column size & name
            if (a instanceof Column) {
                final Column ac = (Column) a;
                aktFieldInfo.setLength(ac.length());
                aktFieldInfo.setDbName(ac.name());
                aktFieldInfo.setNullable(ac.nullable());
            }

            // store PK field separately
            if (a instanceof Id) {
                this.pkFields.add(aktProperty);
                PrimaryKeyInfo info = new PrimaryKeyInfo(((Id) a));
                this.extractGenerator(propertyAnnotations, info);
                this.pkFieldInfo.put(aktProperty, info);
                GlobalPrimaryKeyStore.getStore().put(classToInspect, pkFieldInfo);
            }

            if (a instanceof EmbeddedId) {
                this.pkFields.add(aktProperty);
                PrimaryKeyInfo info = new PrimaryKeyInfo(((EmbeddedId) a));
                this.extractGenerator(propertyAnnotations, info);
                this.pkFieldInfo.put(aktProperty, info);
            }
            
            if (a instanceof JoinColumn) {
            	JoinColumn joinColumnAnnotation = (JoinColumn) a;
            	joinColumnName = joinColumnAnnotation.name();
                getLogger().trace("joinColumn=" + joinColumnName);
                DbMappingInfo dbMappingInfo = new DbMappingInfo(
                            joinColumnAnnotation.name(), joinColumnAnnotation.referencedColumnName());
                mappingInfoList.add(dbMappingInfo);

            }

            if (a instanceof JoinColumns) {
            	JoinColumns joinColumnAnnotation = (JoinColumns) a;
                JoinColumn[] joinColumnAnnotations = joinColumnAnnotation.value();
                for (JoinColumn joinColumn : joinColumnAnnotations) {
                    DbMappingInfo dbMappingInfo = new DbMappingInfo(
                            joinColumn.name(), joinColumn.referencedColumnName());
                    mappingInfoList.add(dbMappingInfo);
                }
            }

            // relations            
            if (a instanceof OneToMany) {
                final OneToMany aC = (OneToMany) a;
                String mappedBy = aC.mappedBy();
                Class targetEntityType = aC.targetEntity();

                if (aktProperty.getGenericTypeClass() != null || !void.class.equals(targetEntityType)) {

                    // the other (many) side is a collection; type is defined by generic collection
                    // or "targetEntity" attribute on annotation (which overrides the generic type!)
                    Class<Object> ty = null;
                    if (!void.class.equals(targetEntityType)) {
                    	ty = aC.targetEntity();
                    }
                    else {
                    	ty = aktProperty.getGenericTypeClass(); 
                    }

                    Property relProp = RelationPropertyResolver.findAttributeForRelationAtOtherSide(
                            ty, mappedBy);
                    final OneToManyRelation o2mReleation = new OneToManyRelation(classToInspect, ty,
                            aktProperty, relProp, aC);

                    getLogger().trace("O2M relation=" + o2mReleation);

                    aktFieldInfo.setEntityReleationInfo(o2mReleation);

                } else {
                    throw new RuntimeException(
                            "The N part (Collection) of a OneToMany collection must be Parametrized");
                }

            } else if (a instanceof ManyToOne) {
                final ManyToOne aC = (ManyToOne) a;
                Property relProp = RelationPropertyResolver.findAttributeForRelationAtOtherSide(aktProperty);
                Class targetClass = null;
                if (relProp != null) {
                    targetClass = relProp.getDeclaringClass();
                }
                // the one side > the target class is declaring class
                final ManyToOneRelation m2oRelation = new ManyToOneRelation(classToInspect, targetClass,
                        aktProperty, relProp, aC);
                
                if (m2oRelation.isUnidirectional()) {
                    m2oRelation.setTargetKeyProperty(
                            RelationPropertyResolver.
                            findPkAttributesAtTheOtherSide(aktProperty));
                }

                getLogger().trace("M2O relation=" + m2oRelation);
                
                aktFieldInfo.setEntityReleationInfo(m2oRelation);
                if (joinColumnName == null) {
                	// No JoinColumn annotation seen (yet), set default 
                	// Mark as being not set, by setting it explicitly to null,
                	// Note that this value might be overwritten by a JoinColumn annotation.
                	aktFieldInfo.setDbName(null);
                        aktFieldInfo.setDbMappingInfoList(null);
                }
            
            } else if (a instanceof OneToOne) {
                final OneToOne aC = (OneToOne) a;
                
                //TODO: PrimaryKeyJoinColumn not yet supported
                String mappedBy = aC.mappedBy();

                OneToOneRelation o2oRelation = null;
                if (mappedBy != null && !"".equals(mappedBy.trim())) {
                    Class targetEntityType = aC.targetEntity();
                    Class ty = null;
                    if (!void.class.equals(targetEntityType)) {
                    	ty = aC.targetEntity();
                    }
                    else {
                    	ty = aktProperty.getType();
                    }
                    getLogger().trace("aC.mappedBy=" + mappedBy + ", targetEntity=" + ty);
                    Property relProp = RelationPropertyResolver.
                            findAttributeForRelationAtOtherSide(
                            ty, mappedBy);
                    o2oRelation = new OneToOneRelation(
                        classToInspect, ty, aktProperty,
                        relProp, aC);
                } else {

                    Property relProp = RelationPropertyResolver.
                            findAttributeForRelationAtOtherSide(
                            aktProperty);
                    Class targetClass = null;
                    if (relProp != null) {
                        
                        targetClass = relProp.getDeclaringClass();
                        getLogger().trace("found target class=" + targetClass);
                    }
                    o2oRelation = new OneToOneRelation(
                        classToInspect, targetClass, aktProperty,
                        relProp, aC);

                    // primary key info for owning side
                    Set<Property> pkFields = 
                            RelationPropertyResolver.findPkAttributesAtTheOtherSide(aktProperty);
                    o2oRelation.setTargetKeyProperty(pkFields);
                }
                
                aktFieldInfo.setEntityReleationInfo(o2oRelation);
                if (joinColumnName == null) {
                	// No JoinColumn annotation seen (yet), set default 
                	// Mark as being not set, by setting it explicitly to null,
                	// Note that this value might be overwritten by a JoinColumn annotation.
                	aktFieldInfo.setDbName(null);
                        aktFieldInfo.setDbMappingInfoList(null);
                }
            }

        }

        if (!isTransient) {
            final Property toAdd = aktProperty;
            this.persitentProperties.add(toAdd);
            this.fieldInfo.put(toAdd, aktFieldInfo);
            
            getLogger().debug("SAVE [" + this.getRepresentingClass().getSimpleName() + "] (" + this.persitentProperties.hashCode() + "): " + aktProperty.getName() +
                    ", savedFieldInfo=" + aktFieldInfo.getDbName() +
                    ", joinColumnName=" + joinColumnName +
                    ", declared in class=" + aktProperty.
                    getDeclaringClass().getName());
        }
        // TODO: composite keys!
        if (joinColumnName != null || !mappingInfoList.isEmpty()) {
        	// Must pass join column info to relation info; can't be done while processing the
        	// JoinColumn annotation, as it might be processed before the ManyToOne.
        	if (aktFieldInfo.getEntityReleationInfo() != null) {
        		if (aktFieldInfo.getEntityReleationInfo() instanceof ManyToOneRelation
                                || aktFieldInfo.getEntityReleationInfo() instanceof OneToOneRelation)  { // TODO (Pd): unify this later with other relation types
                                getLogger().debug("EXPLICIT SET joinColumnName=" + joinColumnName);
        			aktFieldInfo.setDbName(joinColumnName);
                                aktFieldInfo.setDbMappingInfoList(mappingInfoList);
        		}
        	}
        	else {
        		// Later, this should be an exception, but as long as we do not process all relation types (correctly),
        		// just log as warning.
                        getLogger().warn("Detected joinColumn annotation without relation annotation (property="
                                        + aktProperty.getName() + ")");
                }
        }
    }

    /**
     * Returns the representingClass.
     * 
     * @return Returns the representingClass.
     */
    public Class<T> getRepresentingClass() {
        return this.representingClass;
    }

    protected void extractGenerator(Annotation[] propertyAnnotations, PrimaryKeyInfo info) {
        for (Annotation current : propertyAnnotations) {
            if (current instanceof GeneratedValue) {
                info.setGenValue((GeneratedValue) current);
                break;
            }
        }
    }

	/**
	 * Returns the logger for this class.
	 * @return
	 */
	abstract protected Logger getLogger();
}
