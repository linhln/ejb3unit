package com.bm.introspectors;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.EJB;
import javax.annotation.Resource;
import javax.persistence.PersistenceContext;

import org.apache.log4j.Logger;

import com.bm.ejb3metadata.ClassFinder;
import com.bm.ejb3metadata.MetadataAnalyzer;
import com.bm.ejb3metadata.annotations.exceptions.ResolverException;
import com.bm.ejb3metadata.annotations.metadata.ClassAnnotationMetadata;
import com.bm.ejb3metadata.annotations.metadata.EjbJarAnnotationMetadata;
import com.bm.utils.Ejb3Utils;

/**
 * Abstract instrospector fur Session, MDBs und JBoss services.
 * @author Daniel Wiese
 * @since 24.03.2007
 * @param <T> the type
 */
public abstract class AbstractIntrospector<T> {
	private static final Logger log = Logger
			.getLogger(SessionBeanIntrospector.class);

	/** the class represented by this introspector (e.g. the entity bean)* */
	protected final Class<? extends T> representingClass;

	/** the fields to inject * */
	private Set<Property> fieldsToInject = new HashSet<Property>();

	/** we assume thet a injected field has only one annotation * */
	private Map<Property, Annotation> annotationForField = new HashMap<Property, Annotation>();

	/** because the entity manager is often used so, we store it extra * */
	private Property entityManagerField = null;

	private static EjbJarAnnotationMetadata metadata = null;

	protected ClassAnnotationMetadata classMetaData = null;
	
	/**
	 * Constructor.
	 * @param toInspect - the class to inspect.
	 */
	public AbstractIntrospector(Class<? extends T> toInspect) {
		this.representingClass = toInspect;
		classMetaData = getMetaData(toInspect);
	}

	private static synchronized void initialize(Class<?> toInspect) {

		if (metadata == null) {
			final ClassFinder finder = new ClassFinder();
			final List<String> classes = finder.getListOfClasses(toInspect);
			try {
				metadata = MetadataAnalyzer.analyze(Thread.currentThread()
						.getContextClassLoader(), classes, null);
			} catch (ResolverException e) {
				throw new RuntimeException("Class (" + toInspect.getName()
						+ ") can´t be resolved");
			}
		}
	}

	private static synchronized void reinitialize(Class<?> toInspect) {
		metadata = null;
		initialize(toInspect);

	}

	protected static ClassAnnotationMetadata getMetaData(Class toCheck) {
		initialize(toCheck);
		ClassAnnotationMetadata classMeta = metadata
				.getClassAnnotationMetadata(toCheck.getName().replace('.', '/'));
		// try to reinitialize, bacause no metadata was found
		if (classMeta == null) {
			reinitialize(toCheck);
			classMeta = metadata.getClassAnnotationMetadata(toCheck.getName()
					.replace('.', '/'));
		}
		if (classMeta == null) {
			throw new IllegalArgumentException(
					"Can't find any meta data information for the class ("
							+ toCheck.getName() + ")");
		}
		return classMeta;
	}

	/**
	 * If the access type is field, we will extract all the neccessary meta
	 * informations from the fields.
	 * 
	 * @param toInspect -
	 *            the class to inspect
	 */
	protected void processAccessTypeField(Class<? extends T> toInspect) {

		// extract meta information
		Field[] fields = Ejb3Utils.getAllFields(toInspect);
		for (Field aktField : fields) {
			// dont´s introspect fields generated by hibernate
			if (!this.isStatic(aktField) && !aktField.getName().startsWith("$")) {
				Annotation[] fieldAnnotations = aktField.getAnnotations();
				this.processAnnotations(new Property(aktField),
						fieldAnnotations);
			}
		}
	}

	/**
	 * Anylse the annotation of a (field or getterMethod)
	 * 
	 * @param aktProperty -
	 *            the property
	 * @param propertyAnnotations -
	 *            the corresponding annotations
	 */
	private void processAnnotations(Property aktProperty,
			Annotation[] propertyAnnotations) {

		// look into the annotations
		for (Annotation a : propertyAnnotations) {
			// skip transient fields
			if (a instanceof PersistenceContext) {
				this.entityManagerField = aktProperty;
				addAnotatedField(aktProperty, a);
			} else if (a instanceof Resource) {
				addAnotatedField(aktProperty, a);
			} else if (a instanceof EJB) {
				addAnotatedField(aktProperty, a);
			} else {
				log.warn("The Annotation (" + a + ") for field (" + aktProperty
						+ ") will not be injected (is unknown)");
			}
		}
	}

	/**
	 * Register a new field with annotation
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @param aktProperty -
	 *            akt property
	 * @param a -
	 *            akt annotation
	 */
	private void addAnotatedField(Property aktProperty, Annotation a) {
		this.fieldsToInject.add(aktProperty);
		this.annotationForField.put(aktProperty, a);
	}

	/**
	 * Returns the representingClass.
	 * 
	 * @return Returns the representingClass.
	 */
	public Class<? extends T> getRepresentingClass() {
		return this.representingClass;
	}

	/**
	 * Returns the annotationForField.
	 * 
	 * @param field -
	 *            for field
	 * @return Returns the annotationForField.
	 */
	public Annotation getAnnotationForField(Property field) {
		return this.annotationForField.get(field);
	}

	/**
	 * Returns the fieldsToInject.
	 * 
	 * @return Returns the fieldsToInject.
	 */
	public Set<Property> getFieldsToInject() {
		return this.fieldsToInject;
	}

	/**
	 * True is the session bean has an entity manager.
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @return - true if yes
	 */
	public boolean hasEntityManager() {
		return this.entityManagerField != null;
	}

	/**
	 * Returns the field, which holds the reference to the entity manager.
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @return - the em field
	 */
	public Property getEntityManagerField() {
		return this.entityManagerField;
	}

	/**
	 * Returns the classMetaData.
	 * 
	 * @return Returns the classMetaData.
	 */
	public ClassAnnotationMetadata getClassMetaData() {
		return getMetaData(this.representingClass);
	}

	/**
	 * Check if the field is static
	 * 
	 * @param toCheck
	 *            -the field to check
	 * @return - true if static
	 */
	private boolean isStatic(Field toCheck) {
		return Modifier.isStatic(toCheck.getModifiers());

	}

}