package com.bm.introspectors;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.EJB;
import javax.annotation.Resource;
import javax.persistence.PersistenceContext;

import org.apache.log4j.Logger;

import com.bm.ejb3metadata.ClassFinder;
import com.bm.ejb3metadata.MetadataAnalyzer;
import com.bm.ejb3metadata.annotations.exceptions.ResolverException;
import com.bm.ejb3metadata.annotations.metadata.ClassAnnotationMetadata;
import com.bm.ejb3metadata.annotations.metadata.EjbJarAnnotationMetadata;
import com.bm.utils.Ejb3Utils;

/**
 * SessionBeanIntrospector.
 * 
 * @author Daniel Wiese
 * @param <T> -
 *            the type of the session bean
 * @since 08.11.2005
 */
public class SessionBeanIntrospector<T> {

	private static final Logger log = Logger
			.getLogger(SessionBeanIntrospector.class);

	/** the class represented by this introspector (e.g. the entity bean)* */
	private final Class<? extends T> representingClass;

	/** the fields to inject * */
	private Set<Property> fieldsToInject = new HashSet<Property>();

	/** we assume thet a injected field has only one annotation * */
	private Map<Property, Annotation> annotationForField = new HashMap<Property, Annotation>();

	/** because the entity manager is often used so, we store it extra * */
	private Property entityManagerField = null;

	private static EjbJarAnnotationMetadata metadata = null;

	private ClassAnnotationMetadata classMetaData = null;

	/**
	 * Constructor.
	 * 
	 * @param toInspect -
	 *            the sesion bean to inspect
	 */
	public SessionBeanIntrospector(Class<? extends T> toInspect) {
		this.representingClass = toInspect;


		boolean isSessionBean = accept(toInspect);
		if (!isSessionBean) {
			throw new RuntimeException("The class is not a session/service/mdb bean");
		}
		classMetaData = metadata.getClassAnnotationMetadata(toInspect.getName()
				.replace('.', '/'));

		//FIXME: distinguish between field and method based annotations
		// analyse the fields
		this.processAccessTypeField(toInspect);

	}
	
	private static synchronized void initialize(Class<?> toInspect) {

		if (metadata == null) {
			final ClassFinder finder = new ClassFinder();
			final List<String> classes = finder.getListOfClasses(toInspect);
			try {
				metadata = MetadataAnalyzer.analyze(Thread.currentThread()
						.getContextClassLoader(), classes, null);
			} catch (ResolverException e) {
				throw new RuntimeException("Class (" + toInspect.getName()
						+ ") can´t be resolved");
			}
		}
	}

	/**
	 * If the access type is field, we will extract all the neccessary meta
	 * informations from the fields.
	 * 
	 * @param toInspect -
	 *            the class to inspect
	 */
	protected void processAccessTypeField(Class<? extends T> toInspect) {

		// extract meta information
		Field[] fields = Ejb3Utils.getAllFields(toInspect);
		for (Field aktField : fields) {
			// dont´s introspect fields generated by hibernate
			if (!this.isStatic(aktField) && !aktField.getName().startsWith("$")) {
				Annotation[] fieldAnnotations = aktField.getAnnotations();
				this.processAnnotations(new Property(aktField),
						fieldAnnotations);
			}
		}
	}

	/**
	 * Anylse the annotation of a (field or getterMethod)
	 * 
	 * @param aktProperty -
	 *            the property
	 * @param propertyAnnotations -
	 *            the corresponding annotations
	 */
	private void processAnnotations(Property aktProperty,
			Annotation[] propertyAnnotations) {

		// look into the annotations
		for (Annotation a : propertyAnnotations) {
			// skip transient fields
			if (a instanceof PersistenceContext) {
				this.entityManagerField = aktProperty;
				addAnotatedField(aktProperty, a);
			} else if (a instanceof Resource) {
				addAnotatedField(aktProperty, a);
			} else if (a instanceof EJB) {
				addAnotatedField(aktProperty, a);
			} else {
				log.warn("The Annotation (" + a + ") for field (" + aktProperty
						+ ") will not be injected (is unknown)");
			}
		}
	}

	/**
	 * Register a new field with annotation
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @param aktProperty -
	 *            akt property
	 * @param a -
	 *            akt annotation
	 */
	private void addAnotatedField(Property aktProperty, Annotation a) {
		this.fieldsToInject.add(aktProperty);
		this.annotationForField.put(aktProperty, a);
	}

	/**
	 * Returns the representingClass.
	 * 
	 * @return Returns the representingClass.
	 */
	public Class<? extends T> getRepresentingClass() {
		return this.representingClass;
	}

	/**
	 * Returns the annotationForField.
	 * 
	 * @param field -
	 *            for field
	 * @return Returns the annotationForField.
	 */
	public Annotation getAnnotationForField(Property field) {
		return this.annotationForField.get(field);
	}

	/**
	 * Returns the fieldsToInject.
	 * 
	 * @return Returns the fieldsToInject.
	 */
	public Set<Property> getFieldsToInject() {
		return this.fieldsToInject;
	}

	/**
	 * True is the session bean has an entity manager.
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @return - true if yes
	 */
	public boolean hasEntityManager() {
		return this.entityManagerField != null;
	}

	/**
	 * Returns the field, which holds the reference to the entity manager.
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @return - the em field
	 */
	public Property getEntityManagerField() {
		return this.entityManagerField;
	}

	/**
	 * Returns the classMetaData.
	 * @return Returns the classMetaData.
	 */
	public ClassAnnotationMetadata getClassMetaData() {
		return classMetaData;
	}
	
	/**
	 * Check if the field is static
	 * 
	 * @param toCheck
	 *            -the field to check
	 * @return - true if static
	 */
	private boolean isStatic(Field toCheck) {
		return Modifier.isStatic(toCheck.getModifiers());

	}

	/**
	 * Returns true is this intorspector accept this class.
	 * 
	 * @param toCheck -
	 *            to check
	 * @return true id the introspector will accept this class
	 */
	public static boolean accept(Class toCheck) {
		initialize(toCheck);
		ClassAnnotationMetadata classMeta = metadata.getClassAnnotationMetadata(toCheck.getName()
				.replace('.', '/'));
		return classMeta.isBean();
	}


}
