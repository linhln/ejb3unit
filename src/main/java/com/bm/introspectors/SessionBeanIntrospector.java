package com.bm.introspectors;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.annotation.EJB;
import javax.annotation.Resource;
import javax.ejb.Stateful;
import javax.ejb.Stateless;
import javax.persistence.PersistenceContext;

import org.apache.log4j.Logger;

import com.bm.utils.Ejb3Utils;

/**
 * SessionBeanIntrospector.
 * 
 * @author Daniel Wiese
 * @param <T> -
 *            the type of the session bean
 * @since 08.11.2005
 */
public class SessionBeanIntrospector<T> {

	private static final Logger log = Logger
			.getLogger(SessionBeanIntrospector.class);

	/** the class represented by this introspector (e.g. the entity bean)* */
	private final Class<? extends T> representingClass;

	/** the fields to inject * */
	private Set<Property> fieldsToInject = new HashSet<Property>();

	/** we assume thet a injected field has only one annotation * */
	private Map<Property, Annotation> annotationForField = new HashMap<Property, Annotation>();

	/** becase the entity manager is often used wie store it extra * */
	private Property entityManagerField = null;

	/**
	 * Constructor.
	 * 
	 * @param toInspect -
	 *            the sesion bean to inspect
	 */
	public SessionBeanIntrospector(Class<? extends T> toInspect) {
		this.representingClass = toInspect;

		Annotation[] classAnnotations = toInspect.getAnnotations();

		boolean isSessionBean = accept(toInspect);

		// display the right massage
		for (Annotation a : classAnnotations) {
			if (a instanceof Stateless) {
				log.info("The class " + toInspect.getCanonicalName()
						+ " is a Stateless-Session-Bean");
			} else if (a instanceof Stateful) {
				log.info("The class " + toInspect.getCanonicalName()
						+ " is a Statefull-Session-Bean");
			}
		}
		// analyse the fields
		this.processAccessTypeField(toInspect);

		if (!isSessionBean) {
			throw new RuntimeException("The class is not a session bean");
		}
	}

	/**
	 * Constructor. - Protected only used by sublcases
	 * 
	 * @param toInspect -
	 *            the class to inspect
	 * @param flagForProvateContructor -
	 *            only to distinguisch between normal contructor.
	 */
	protected SessionBeanIntrospector(Class<? extends T> toInspect,
			boolean flagForProvateContructor) {
		this.representingClass = toInspect;
		log.debug("Protected contructor called: " + flagForProvateContructor);

	}

	/**
	 * If the access typeis field, we will extract all the neccessary meta
	 * informations form the fields
	 * 
	 * @param toInspect -
	 *            the class to inspect
	 */
	protected void processAccessTypeField(Class<? extends T> toInspect) {
		// extract meta information
		Field[] fields = Ejb3Utils.getAllFields(toInspect);
		for (Field aktField : fields) {
			// dont´s introspect fields generated by hibernate
			if (!this.isStatic(aktField) && !aktField.getName().startsWith("$")) {
				Annotation[] fieldAnnotations = aktField.getAnnotations();
				this.processAnnotations(new Property(aktField),
						fieldAnnotations);
			}
		}
	}

	/**
	 * Anylse the annotation of a (field or getterMethod)
	 * 
	 * @param aktProperty -
	 *            the property
	 * @param propertyAnnotations -
	 *            the corresponding annotations
	 */
	private void processAnnotations(Property aktProperty,
			Annotation[] propertyAnnotations) {

		// look into the annotations
		for (Annotation a : propertyAnnotations) {
			// skip transient fields
			if (a instanceof PersistenceContext) {
				this.entityManagerField = aktProperty;
				addAnotatedField(aktProperty, a);
			} else if (a instanceof Resource) {
				addAnotatedField(aktProperty, a);
			} else if (a instanceof EJB) {
				addAnotatedField(aktProperty, a);
			} else {
				log.warn("The Annotation (" + a + ") for field (" + aktProperty
						+ ") will not be injected (is unknown)");
			}
		}
	}

	/**
	 * Register a new field with annotation
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @param aktProperty -
	 *            akt property
	 * @param a -
	 *            akt annotation
	 */
	private void addAnotatedField(Property aktProperty, Annotation a) {
		this.fieldsToInject.add(aktProperty);
		this.annotationForField.put(aktProperty, a);
	}

	/**
	 * Returns the representingClass.
	 * 
	 * @return Returns the representingClass.
	 */
	public Class<? extends T> getRepresentingClass() {
		return this.representingClass;
	}

	/**
	 * Returns the annotationForField.
	 * 
	 * @param field -
	 *            for field
	 * @return Returns the annotationForField.
	 */
	public Annotation getAnnotationForField(Property field) {
		return this.annotationForField.get(field);
	}

	/**
	 * Returns the fieldsToInject.
	 * 
	 * @return Returns the fieldsToInject.
	 */
	public Set<Property> getFieldsToInject() {
		return this.fieldsToInject;
	}

	/**
	 * True is the session bean has an entity manager.
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @return - true if yes
	 */
	public boolean hasEntityManager() {
		return this.entityManagerField != null;
	}

	/**
	 * Returns the field, which holds the reference to the entity manager.
	 * 
	 * @author Daniel Wiese
	 * @since 08.11.2005
	 * @return - the em field
	 */
	public Property getEntityManagerField() {
		return this.entityManagerField;
	}

	/**
	 * Check if the field is static
	 * 
	 * @param toCheck
	 *            -the field to check
	 * @return - true if static
	 */
	private boolean isStatic(Field toCheck) {
		return Modifier.isStatic(toCheck.getModifiers());

	}

	/**
	 * Returns true is this intorspector accept this class.
	 * 
	 * @param toCheck -
	 *            to check
	 * @return true id the introspector will accept this class
	 */
	public static boolean accept(Class toCheck) {
		Annotation[] classAnnotations = toCheck.getAnnotations();

		// iterate over the annotations to locate the MaxLength constraint
		// if it exists
		boolean isSessionBean = false;
		for (Annotation a : classAnnotations) {
			if (a instanceof Stateless) {
				isSessionBean = true;
			}
		}

		return isSessionBean;
	}

}
